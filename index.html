<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Morpion Solitaire ‚Äì Croix de Malte</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="preload" as="image" href="images/monfond.jpg">
  <link rel="icon" type="image/png" href="favicon.png?v=1">

<style>

/* === Mise en page g√©n√©rale === */

/* === GLOBAL === */

html, body {
  margin: 0;
  padding: 0;
  overflow-x: hidden;
  max-width: 100%;
}

* {
  box-sizing: border-box;
}

img, canvas {
  max-width: 100%;
}

/* utile si tu veux r√©utiliser .flex */
.flex {
  flex-wrap: wrap;
}

body {
  font-family: Arial, sans-serif;
  background-image: url("images/monfond.jpg");
  background-size: cover;
  background-position: center;
  background-attachment: fixed;
}

#gameContainer {
  display: flex;
  flex-direction: column;
  height: 100vh;
}

/* === TOP BAR === */

#topBar {
  position: sticky;
  top: 0;
  z-index: 10000;
  display: flex;
  flex-wrap: wrap;
  justify-content: flex-start;
  align-items: center;
  gap: 20px;
  background: #333;
  color: white;
  padding: 10px 20px;
  width: 100%;
}

#titleArea h1 {
  margin: 0;
  font-size: clamp(18px, 3vw, 24px);
}

#subtitle {
  font-size: clamp(12px, 2vw, 14px);
  opacity: 0.9;
}

#statusArea {
  display: flex;
  flex-direction: column;
  gap: 2px;
  text-align: right;
  font-size: clamp(12px, 2vw, 15px);
  flex-shrink: 0;
}

#statusArea .label {
  font-weight: 600;
}

/* === BUTTONS === */

#buttonsArea {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  align-items: center;
}

.main-btn {
  padding: 8px 14px;
  border: none;
  cursor: pointer;
  border-radius: 4px;
  font-size: clamp(12px, 2vw, 14px);
  white-space: nowrap;
  background: #0078d4;
  color: white;
  transition: opacity 0.2s, background-color 0.2s;
}

.main-btn:hover {
  opacity: 0.85;
  background-color: #006cc0;
}

.main-btn.disabled {
  opacity: 0.4;
  cursor: not-allowed;
  pointer-events: none;
}

/* === HELP CLOSE BUTTON === */

#closeHelpBtn {
  position: absolute;
  top: 12px;
  right: 12px;
}

/* === HELP CONTENT === */

#helpContent {
  background: #fff;
  width: min(800px, 90vw);
  max-height: 80vh; /* emp√™che de d√©passer sous le bandeau */
  padding: 30px;
  border-radius: 12px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.25);
  position: relative;
  overflow-y: auto;
  box-sizing: border-box;
}

.aide-separator {
  width: 100%;
  height: 1px;
  background: #ddd;
  margin: 16px 0;
}

/* === MAIN AREA === */

#mainArea {
  display: flex;
  flex: 1;
  align-items: flex-start;
  overflow: hidden;
}

#mainArea {
  min-height: 0;
}

/* === BOARD === */

#boardWrapper {
  padding-top: 20px;
  padding-left: clamp(10px, 4vw, 60px);
  flex: 1;
  overflow: visible;
}

#boardWrapper {
  min-height: 0;
}

.board-frame {
  border: 30px solid transparent;
  background-clip: padding-box;
  border-image: url("images/plateau.jpg") 30 round;
}

/* plateau responsive */

#canvasContainer {
  position: relative;
  width: min(600px, 90vw);
  height: min(600px, 90vw);
  overflow: visible;
  z-index: 0;
}

#canvasContainer::before {
  content: "";
  position: absolute;

  width: calc(min(600px, 90vw) + 20px);
  height: calc(min(600px, 90vw) + 20px);

  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);

  background: radial-gradient(circle,
    rgba(255,255,255,0.25) 40%,
    rgba(0,0,0,0.25) 100%
  );

  pointer-events: none;

  z-index: -1;
}

#gameCanvas {
  width: 100% !important;
  height: 100% !important;
  background: #fafafa;
  display: block;

  position: relative;
  z-index: 1;
}

/* === LABELS === */

#topLabels, #leftLabels {
  position: absolute;
  pointer-events: none;
}

#topLabels span, #leftLabels span {
  position: absolute;
  font-size: clamp(10px, 1.5vw, 12px);
  color: #444;
}

#topLabels {
  top: -22px;
  width: 100%;
}

#leftLabels {
  left: -20px;
  height: 100%;
}

/* === FLASH MESSAGES === */

#flashContainer {
  position: fixed;
  top: 120px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 9999;
  display: flex;
  flex-direction: column;
  gap: 10px;
  pointer-events: none;
}

.flashMessage {
  background: rgba(30, 30, 30, 0.92);
  box-shadow: 0 2px 6px rgba(0,0,0,0.25);
  color: #fff;
  padding: 8px 16px;
  border-radius: 6px;
  font-size: 14px;
  opacity: 0;
  transform: translateY(-10px);
  transition: opacity 0.3s ease, transform 0.3s ease;
}

.flashMessage.show {
  opacity: 1;
  transform: translateY(0);
}

/* === SIDE PANEL === */

#sidePanel {
  margin-top: 10px;
  width: clamp(220px, 28vw, 320px);
  background: #fafafa;
  border: 1px solid #e0e0e0;
  padding: 20px 12px 10px;
  box-shadow: 0 0 8px rgba(0,0,0,0.25);
  border-radius: 8px;
  overflow-y: auto;
}

#historyTitle {
  color: #222;
  font-weight: 600;
  margin: 0 0 12px;
  padding-bottom: 6px;
  border-bottom: 1px solid #e0e0e0;
}

#historyPanel {
  max-height: 700px;
  overflow-y: auto;
}

#historyList {
  list-style: none;
  padding: 0;
  margin: 0;
  font-size: 13px;
}

#historyList li {
  padding: 4px 0;
  border-bottom: 1px dashed #e6e6e6;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

#historyList li.gain { color: #008a00; font-weight: 600; }
#historyList li.loss { color: #cc0000; font-weight: 600; }
#historyList li.neutral { color: #222; }

/* === HELP OVERLAY === */

#helpOverlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.45);
  display: none;
  align-items: flex-start; /* aligne en haut */
  justify-content: center;
  padding-top: 100px; /* hauteur du bandeau + marge */
  z-index: 999999;
}

#helpOverlay.hidden {
  display: none !important;
}

/* === GENERIC OVERLAY === */

.overlay {
  position: fixed;
  inset: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  background: rgba(0,0,0,0.5);
  z-index: 2000;
}

.overlay.hidden {
  display: none !important;
  pointer-events: none !important;
}

/* === END GAME PANEL === */

#endGamePanel {
  background: #fafafa;
  padding: 30px 40px;
  border-radius: 10px;
  box-shadow: 0 0 12px rgba(0,0,0,0.15);
  text-align: center;
  border: 1px solid #e0e0e0;
}

/* === BEST SCORE PANEL === */

#bestScoreOverlay .panel {
  min-width: 460px;
  max-width: 640px;
  padding: 20px 30px;
  border-radius: 12px;
  text-align: center;
  background: #fff;
  box-shadow: 0 8px 20px rgba(0,0,0,0.25);
  animation: popIn 0.25s ease-out;
  isolation: isolate;
}
    
#bestScoreContent {
  width: auto;
  max-width: 640px;
  padding: 24px;
  box-sizing: border-box;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 24px;
}

.record-line {
  display: inline-block;
  margin: 0 auto;
  font-size: 1.1em;
  white-space: nowrap;
}

#bestScoreContent button {
  align-self: center;
  padding: 8px 16px;
  font-size: 1em;
  margin-top: 8px;
}

/* === TUTORIAL BUBBLE === */

#tutorialBubble {
  position: absolute;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(30, 30, 30, 0.92);
  color: #fff;
  padding: 14px 20px;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.25);
  font-size: 16px;
  font-weight: 500;
  max-width: 85%;
  text-align: center;
  z-index: 3000;
  opacity: 0;
  transition: opacity 0.3s ease;
  pointer-events: none;
  display: none;
}

/* === MODAL G√âN√âRIQUE === */

.modal {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.6);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 20000;
  padding: 20px; /* important pour petits √©crans */
  overflow: hidden;
}

.modal-content {
  margin: auto;
  background: white;
  padding: 20px 30px;
  border-radius: 10px;
  text-align: center;
  box-shadow: 0 4px 12px rgba(0,0,0,0.25);
  font-size: 18px;

  /* Adaptation automatique */
  max-width: 90vw;
  max-height: 90vh;
  overflow: auto;
  box-sizing: border-box;
}

#readyModal {
  z-index: 200000 !important;
}

/* === ANIMATIONS === */

.fade-hidden {
  opacity: 0;
  transform: translateY(-20px) scale(0.98);
  transition: opacity 0.4s ease, transform 0.4s ease;
}

.blink {
  animation: blinkAnim 0.4s ease-in-out 2;
}

@keyframes blinkAnim {
  50% { transform: scale(1.4); }
}

/* Animation premium : arriv√©e du plateau */

.slide-in-premium {
  opacity: 0;
  transform: translateX(120%) rotate(3deg) scale(0.95);
  transition:
    opacity 0.6s ease-out,
    transform 1.8s cubic-bezier(0.25, 0.8, 0.3, 1);
}

.slide-in-premium.show {
  opacity: 1;
  transform: translateX(0) rotate(0deg) scale(1);
  animation: boardBounce 0.35s ease-out 1 1.8s;
}

@keyframes boardBounce {
  0%   { transform: translateX(0) scale(1); }
  40%  { transform: translateX(-12px) scale(1.01); }
  70%  { transform: translateX(4px) scale(0.995); }
  100% { transform: translateX(0) scale(1); }
}


  </style>
</head>

<body>
  <div id="readyModal" class="modal">
  <div class="modal-content">
    <p>Pr√™t √† jouer ?</p>
    <button id="readyBtn" class="main-btn">Oui</button>
  </div>
</div>


  <div id="gameContainer">

    <!-- === TOP BAR === -->
    <div id="topBar">

      <div id="titleArea">
        <h1>Morpion Solitaire ‚Äì Croix de Malte</h1>
        <div id="subtitle">
          Objectif : cr√©er des lignes de 5 points selon les r√®gles du Morpion Solitaire
        </div>
      </div>

      <div id="statusArea">
        <div>
          <span class="label">Score :</span>
          <span id="scoreValue">0</span>
        </div>
        <div>
          <span class="label">Temps :</span>
          <span id="timerValue">00:00</span>
        </div>
        <div>
          <span class="label">Jokers :</span>
          <span id="jokersCombinedValue">0 / 0</span>
        </div>
        <div>
          <span class="label">Retours :</span>
          <span id="undoCount">0</span>
        </div>
      </div>

      <div id="buttonsArea">
        <button id="resetBtn" class="main-btn">Rejouer</button>
        <button id="undoBtn" class="main-btn">Retour</button>
        <button id="pauseBtn" class="main-btn">Pause</button>
        <button id="stepBtn" class="main-btn">Pas √† Pas</button>
        <button id="helpBtn" class="main-btn">Aide</button>
        <button id="soundBtn" class="main-btn">Son : on</button>

        <span id="bestScoreTop" class="best-score-info"></span>

      </div>

    </div> <!-- /topBar -->

<!-- === MAIN AREA (historique + grille) === -->
<div id="mainArea">

  <!-- HISTORIQUE -->
  <div id="sidePanel"> 
    <h2 id="historyTitle">Historique</h2>   
    <div id="historyPanel">     
      <ul id="historyList"></ul>
    </div>
  </div>

  <!-- GRILLE -->
  <div id="boardWrapper">
    <div id="canvasContainer" class="board-frame slide-in-premium">

      <!-- Rep√®res horizontaux -->
      <div id="topLabels">
        <span>1</span><span>5</span><span>10</span><span>15</span><span>20</span><span>25</span><span>30</span>
      </div>

      <!-- Rep√®res verticaux -->
      <div id="leftLabels">
        <span>1</span><span>5</span><span>10</span><span>15</span><span>20</span><span>25</span><span>30</span>
      </div>

      <!-- CANVAS 600√ó600 -->
      <canvas id="gameCanvas" width="600" height="600"></canvas>
      <div id="tutorialBubble"></div>
      <div id="jokerEffectContainer"></div>

    </div>

  </div>

</div>



    </div> <!-- /gameContainer -->


  <!-- === HELP OVERLAY === -->
<div id="helpOverlay" class="overlay hidden">
  <div id="helpContent">

    <button class="main-btn" id="closeHelpBtn">Fermer</button>

    <h2>üìñ Aide</h2>
    <div class="aide-separator"></div>

    <h3>L‚Äôobjectif</h3>
    <p>Tracer un maximum de lignes de 5 points en partant de la Croix de Malte avec les points noirs actifs.</p>
    <div class="aide-separator"></div>

    <h3>Comment jouer</h3>
    <ol>
      <li>Rep√®re une ligne possible de 5 points align√©s avec un minimum de 4 points d√©j√† actifs.</li>
      <li>Clique sur l‚Äôun des points d‚Äôextr√©mit√©, puis sur le point d‚Äôarriv√©e.</li>
      <li>La ligne sera cr√©√©e automatiquement si elle est valide.</li>
      <li> Clique sur le bouton "Pas √† Pas" pour voir la cr√©ation d'une ligne.</li>
    </ol>
    <div class="aide-separator"></div>

    <h3>R√®gles</h3>
    <ul>
      <li>Une ligne doit faire exactement 5 points.</li>
      <li>Une ligne doit contenir au pr√©alable au moins 2 points d√©j√† actifs.</li>
      <li>Les lignes peuvent se croiser, mais pas se superposer.</li>
    </ul>
    <div class="aide-separator"></div>

    <h3>Jokers</h3>
    <p>Gagn√©s lorsqu‚Äôune ligne utilise 5 points d√©j√† actifs.</p>
    <p><strong>Utilisation :</strong></p>
    <ul>
      <li>1 joker si la ligne comporte seulement 3 points actifs.</li>
      <li>2 jokers si elle ne comporte que 2 points actifs.</li>
      <li><em>Les lignes avec moins de 2 points actifs ne sont pas autoris√©es.</em></li>
    </ul>

  </div>
</div>



<!-- === SONS === -->
<audio id="clickSound" src="sounds/click.mp3" preload="auto"></audio>
<audio id="errorSound" src="sounds/error.mp3" preload="auto"></audio>
<audio id="successSound" src="sounds/success.mp3" preload="auto"></audio>
<audio id="tutorialSound" src="sounds/tutorial.mp3" preload="auto"></audio>
<audio id="jokerSound" src="sounds/joker.mp3" preload="auto"></audio>
<audio id="jokerLossSound" src="sounds/jokerloss.mp3" preload="auto"></audio>
<audio id="endGameSound" src="sounds/end.mp3" preload="auto"></audio>
<audio id="startGameSound" src="sounds/start.mp3" preload="none"></audio>
<audio id="newRecordSound" src="sounds/new-record.mp3" preload="auto"></audio>


<div id="flashContainer"></div>

<div id="endGameOverlay" class="overlay hidden">
  <div id="endGamePanel">
    <h2>Partie termin√©e</h2>
    <p id="finalScore"></p>
   <button id="closeEndGame" class="main-btn">OK</button>
  </div>
</div>

<div id="bestScoreOverlay" class="overlay hidden">
  <div class="panel">
    <h2>üéâ Nouveau record</h2>

    <div id="bestScoreContent"></div>

    <button id="closeBestScore" class="main-btn">Fermer</button>
  </div>
</div>

<script>

// ===============================
//   VARIABLES GLOBALES
// ===============================

let soundEnabled = true;
let audioUnlocked = false;

const size = 34;
let offset;
let spacing;

// Variables de jeu
let selectedStart = null;
let score = 0;
let paused = false;
let gameOver = false;

let canvas = null;
let ctx = null;
let tutorialBtn = null;


let activePoints = new Set();
let permanentPoints = new Set();
let usedEdges = new Set();
let validatedSegments = [];

let jokersAvailable = 0;
let jokersTotal = 0;

let timerInterval = null;
let timerSeconds = 0;
let timerRunning = false;

let undoCount = 0;

// Tutoriel
let currentTutorialStep = 0;
let tutorialRunning = false;

const tutorialSteps = [
  { message: "Exemple 1 : une ligne horizontale.", start: { x: 15, y: 12 }, end: { x: 19, y: 12 } },
  { message: "Exemple 2 : une ligne verticale.",   start: { x: 15, y: 12 }, end: { x: 15, y: 16 } },
  { message: "Exemple 3 : une ligne diagonale.",   start: { x: 12, y: 16 }, end: { x: 16, y: 12 } }
];

// ===============================
//   MEILLEUR SCORE
// ===============================

function saveBestScore(data) {
  try {
    localStorage.setItem("bestScoreData", JSON.stringify(data));
  } catch(e) {
    console.error("Erreur sauvegarde meilleur score :", e);
  }
}

function loadBestScore() {
  try {
    const raw = localStorage.getItem("bestScoreData");
    return raw ? JSON.parse(raw) : null;
  } catch(e) {
    console.error("Erreur chargement meilleur score :", e);
    return null;
  }
}

function updateBestScoreTop() {
  const el = document.getElementById("bestScoreTop");
  if (!el) return;

  const best = loadBestScore();
  if (!best || isNaN(Number(best.score))) {
    el.textContent = "";
    return;
  }

  const score = Number(best.score);
  const minutes = Math.floor(best.duration / 60);
  const seconds = best.duration % 60;
  const timeStr = `${minutes}:${seconds.toString().padStart(2, "0")}`;

  el.innerHTML =
    `<span class="emoji">üèÜ</span> ${score} lignes ` +
    `<span class="emoji">‚Ü©Ô∏è</span>${best.returnsUsed} ` +
    `<span class="emoji">üÉè</span>${best.jokersUsed} ` +
    `<span class="emoji">‚è±Ô∏è</span>${timeStr}`;
}

function showBestScorePanel() {
  const panel = document.getElementById("bestScoreContent");
  if (!panel) return;

  const best = loadBestScore();
  if (!best) {
    panel.innerHTML = "<p>Aucun record enregistr√© pour le moment.</p>";
  } else {
    const score = Number(best.score);
    const minutes = Math.floor(best.duration / 60);
    const seconds = best.duration % 60;
    const timeStr = `${minutes}:${seconds.toString().padStart(2, "0")}`;

    panel.innerHTML = `
  <div class="record-line">
    üèÜ ${score} lignes ‚Äî ${best.returnsUsed} retour${best.returnsUsed > 1 ? "s" : ""} ‚Äî ${best.jokersUsed} joker${best.jokersUsed > 1 ? "s" : ""} ‚Äî ${timeStr}
  </div>
`;

  }

  document.getElementById("bestScoreOverlay").classList.remove("hidden");
}


document.getElementById("closeBestScore").addEventListener("click", () => {
  document.getElementById("bestScoreOverlay").classList.add("hidden");
});

function updateSoundButton() {
  const btn = document.getElementById("soundBtn");
  btn.textContent = soundEnabled ? "Son : on" : "Son : off";
}

// ===============================
//   SAUVEGARDE PARTIE EN COURS
// ===============================

function saveGameState() {
  if (tutorialRunning) return; // jamais pendant le tutoriel

  const data = {
    activePoints: Array.from(activePoints),
    permanentPoints: Array.from(permanentPoints),
    usedEdges: Array.from(usedEdges),
    validatedSegments, // tableau simple ‚Üí OK
    historyStack: JSON.parse(JSON.stringify(validatedSegments)),
    score,
    jokersAvailable,
    jokersTotal,
    undoCount,
    timerSeconds,
    gameOver,
    soundEnabled,
    paused
    
  };

  try {
    localStorage.setItem("currentGameState", JSON.stringify(data));
  } catch (e) {
    console.error("Erreur sauvegarde partie :", e);
  }
}

function loadGameState() {
  try {
    const raw = localStorage.getItem("currentGameState");
    return raw ? JSON.parse(raw) : null;
  } catch (e) {
    console.error("Erreur chargement partie :", e);
    return null;
  }
}

function restoreGameState() {
  
const data = loadGameState();
  if (!data) return false;

  // V√©rification stricte : donn√©es essentielles pr√©sentes
  if (!Array.isArray(data.activePoints) ||
      !Array.isArray(data.permanentPoints) ||
      !Array.isArray(data.validatedSegments) ||
      data.activePoints.length === 0 ||
      data.permanentPoints.length === 0) {
    return false;
  }

  // Restaurer les Sets
  activePoints = new Set(data.activePoints);
  permanentPoints = new Set(data.permanentPoints);
  usedEdges = new Set(data.usedEdges || []);

  // Restaurer les tableaux simples
  validatedSegments = data.validatedSegments;

  // Restaurer les variables simples
  score = data.score ?? 0;
  jokersAvailable = data.jokersAvailable ?? 0;
  jokersTotal = data.jokersTotal ?? 0;
  undoCount = data.undoCount ?? 0;
  timerSeconds = data.timerSeconds ?? 0;
  gameOver = data.gameOver ?? false;
  paused = data.paused ?? false;

  // Restaurer l'historique
  const historyList = document.getElementById("historyList");
  historyList.innerHTML = "";
  if (data.historyStack) {
    data.historyStack.forEach(entry => {
      appendHistoryEntry(entry.points, entry.activeCount);
    });
  }

  // Restaurer l'√©tat du son
  soundEnabled = data.soundEnabled ?? true;
  updateSoundButton();

  return true;
}


// Sauvegarde automatique √† chaque coup
function autoSave() {
  saveGameState();
}

// Sauvegarde √† la fermeture
window.addEventListener("beforeunload", saveGameState);


// ===============================
//   FONCTIONS AUDIO
// ===============================

function playClickSound() { if (!soundEnabled) return; const a=document.getElementById("clickSound"); a.currentTime=0; a.play(); }
function playErrorSound() { if (!soundEnabled) return; const a=document.getElementById("errorSound"); a.currentTime=0; a.play(); }
function playSuccessSound() { if (!soundEnabled) return; const a=document.getElementById("successSound"); a.currentTime=0; a.play(); }
function playTutorialSound() { if (!soundEnabled) return; const a=document.getElementById("tutorialSound"); a.currentTime=0; a.play(); }
function playJokerGainSound() { if (!soundEnabled) return; const a=document.getElementById("jokerSound"); a.currentTime=0; a.play(); }
function playJokerLossSound() { if (!soundEnabled) return; const a=document.getElementById("jokerLossSound"); a.currentTime=0; a.play(); }
function playEndGameSound() { if (!soundEnabled) return; const a=document.getElementById("endGameSound"); a.currentTime=0; a.play(); }
function playStartGameSound() { if (!soundEnabled) return; const a=document.getElementById("startGameSound"); a.currentTime=0; a.play(); }
function playNewRecordSound() {
    if (!soundEnabled) return;
    const a = document.getElementById("newRecordSound");
    if (a) a.play();
}


function unlockAudio() {
  const ids = ["clickSound"];
  ids.forEach(id => {
    const a = document.getElementById(id);
    a.volume = 0.001;
    a.play().then(() => {
      setTimeout(() => { a.pause(); a.currentTime = 0; a.volume = 1; }, 30);
    }).catch(()=>{});
  });
}


//// ===============================
////   SAUVEGARDE
//// ===============================



// ===============================
//   UTILITAIRES UI
// ===============================

function flash(message, type = "") {
  const div = document.createElement("div");
  div.className = "flashMessage " + type;
  div.textContent = message;
  document.getElementById("flashContainer").appendChild(div);
  requestAnimationFrame(() => div.classList.add("show"));
  setTimeout(() => { 
    div.classList.remove("show"); 
    setTimeout(() => div.remove(), 300); 
  }, 1500);
}

function showTutorialBubble(text, icon = "") {
  const bubble = document.getElementById("tutorialBubble");
  bubble.innerHTML = icon ? `<span style="margin-right:6px;">${icon}</span>${text}` : text;
  bubble.style.display = "block";
  requestAnimationFrame(() => bubble.style.opacity = "1");
}

function hideTutorialBubble() {
  const bubble = document.getElementById("tutorialBubble");
  bubble.style.opacity = "0";
  setTimeout(() => bubble.style.display = "none", 300);
}

function updateCounters() {
  document.getElementById("scoreValue").textContent = score;
  document.getElementById("jokersCombinedValue").textContent = `${jokersAvailable} / ${jokersTotal}`;
}

function setButtonsEnabled(enabled) {
  document.querySelectorAll("#buttonsArea button").forEach(btn => {
    btn.disabled = !enabled;
    btn.classList.toggle("disabled", !enabled);
  });
}

function formatTime(sec) {
  const m = Math.round(sec / 60).toString().padStart(2, "0");
  const s = (sec % 60).toString().padStart(2, "0");
  return `${m}:${s}`;
}

function startTimer() {
  if (timerRunning) return;
  timerRunning = true;
  timerInterval = setInterval(() => {
    timerSeconds++;
    autoSave();
    document.getElementById("timerValue").textContent = formatTime(timerSeconds);
  }, 1000);
}

function stopTimer() {
  timerRunning = false;
  clearInterval(timerInterval);
  timerInterval = null;
}

function resetTimer() {
  clearInterval(timerInterval);
  timerInterval = null;
  timerSeconds = 0;
  timerRunning = false;
  document.getElementById("timerValue").textContent = "00:00";
}

function updateTutorialButtonState() {
  if (validatedSegments.length > 0) {
    tutorialBtn.disabled = true;
    tutorialBtn.classList.add("disabled");
  } else {
    tutorialBtn.disabled = false;
    tutorialBtn.classList.remove("disabled");
  }
}


// ===============================
//   DESSIN DE LA GRILLE
// ===============================

const visualOrigin = offset - spacing;

function drawGrid() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.strokeStyle = "#ddd";
  ctx.lineWidth = 1;

  for (let y = 0; y < size; y++) {
    ctx.beginPath();
    ctx.moveTo(offset, offset + y * spacing);
    ctx.lineTo(offset + (size - 1) * spacing, offset + y * spacing);
    ctx.stroke();
  }

  for (let x = 0; x < size; x++) {
    ctx.beginPath();
    ctx.moveTo(offset + x * spacing, offset);
    ctx.lineTo(offset + x * spacing, offset + (size - 1) * spacing);
    ctx.stroke();
  }
}

function drawPoint(x, y, color = "#000") {
  ctx.beginPath();
  ctx.arc(offset + x * spacing, offset + y * spacing, 3, 0, Math.PI * 2);
  ctx.fillStyle = color;
  ctx.fill();
}


function drawSegment(segmentPoints) {
  const [sx, sy] = segmentPoints[0].split(",").map(Number);
  const [ex, ey] = segmentPoints[4].split(",").map(Number);
  ctx.strokeStyle = "#000";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(offset + sx * spacing, offset + sy * spacing);
  ctx.lineTo(offset + ex * spacing, offset + ey * spacing);
  ctx.stroke();
}

// ===============================
//   TROUVER LE POINT LE PLUS PROCHE
// ===============================

function getNearestPoint(mx, my) {
  let best = null;
  let bestDist = Infinity;

  for (let y = 0; y < size; y++) {
    for (let x = 0; x < size; x++) {
      const px = offset + x * spacing;
      const py = offset + y * spacing;

      const dx = mx - px;
      const dy = my - py;
      const dist = Math.sqrt(dx*dx + dy*dy);

      if (dist < bestDist) {
        bestDist = dist;
        best = { x, y };
      }
    }
  }

  if (bestDist <= 20) return best;

  return null;
}


// ===============================
//   CROIX DE MALTE
// ===============================

function drawMaltaCross() {
  permanentPoints.forEach(key => {
    const [x, y] = key.split(",").map(Number);
    drawPoint(x, y);
  });
}

function initMaltaCross() {

  permanentPoints.clear();
  activePoints.clear();

  // Construction brute de la croix
  let x = 0, y = 0;
  const pts = [];
  const add = (px, py) => pts.push({ x: px, y: py });
  add(x, y);

  const steps = [
    [1,0,3],[0,1,3],[1,0,3],[0,1,3],
    [-1,0,3],[0,1,3],[-1,0,3],[0,-1,3],
    [-1,0,3],[0,-1,3],[1,0,3],[0,-1,3]
  ];

  for (const [dx, dy, n] of steps) {
    for (let i = 0; i < n; i++) {
      x += dx;
      y += dy;
      add(x, y);
    }
  }

  // Point de r√©f√©rence dans la croix brute
  const refX = -3;
  const refY = 3;

  // Point logique o√π placer ce point
  const targetLeftX = 12;
  const targetLeftY = 15;

  const offsetX = targetLeftX - refX; // 15
  const offsetY = targetLeftY - refY; // 12

  // Application de l‚Äôoffset
  pts.forEach(p => {
    const key = `${p.x + offsetX},${p.y + offsetY}`;
    permanentPoints.add(key);
    activePoints.add(key);
  });

  autoSave();
}

function redrawEverything() {

  // Le canvas s‚Äôadapte visuellement
  canvas.width = canvas.clientWidth;
  canvas.height = canvas.clientHeight;

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  drawGrid();

  validatedSegments.forEach(seg => drawSegment(seg.points));

  activePoints.forEach(key => {
    const [x, y] = key.split(",").map(Number);
    drawPoint(x, y);
  });
}


// ===============================
//   AR√äTES
// ===============================

function edgeKey(a, b) {
  return (a < b) ? `${a}|${b}` : `${b}|${a}`;
}

function edgesOfSegment(segmentKeys) {
  const edges = [];
  for (let i = 0; i < 4; i++) edges.push(edgeKey(segmentKeys[i], segmentKeys[i+1]));
  return edges;
}


// ===============================
//   JOKERS
// ===============================

function gainJoker() {
  jokersAvailable++;
  autoSave();
  jokersTotal++;
  autoSave();
  updateCounters();

  const container = document.getElementById("jokerEffectContainer");
  const float = document.createElement("div");
  float.className = "joker-float";
  float.textContent = "+1";
  float.style.left = (canvas.width / 2 - 10) + "px";
  float.style.top  = (canvas.height / 2 - 20) + "px";
  container.appendChild(float);
  setTimeout(() => container.removeChild(float), 1000);

  playJokerGainSound();
}

function loseJoker(amount) {
  jokersAvailable -= amount;
  updateCounters();

  const container = document.getElementById("jokerEffectContainer");
  const float = document.createElement("div");
  float.className = "joker-loss";
  float.textContent = `-${amount}`;
  float.style.left = (canvas.width / 2 - 12) + "px";
  float.style.top  = (canvas.height / 2 - 20) + "px";
  container.appendChild(float);
  setTimeout(() => container.removeChild(float), 1000);

  playJokerLossSound();
}

// ===============================
//   VALIDATION D‚ÄôUN SEGMENT
// ===============================

function getSegmentBetween(start, end) {
  const dx = end.x - start.x;
  const dy = end.y - start.y;

  const aligned =
    (dx === 0 && Math.abs(dy) === 4) ||
    (dy === 0 && Math.abs(dx) === 4) ||
    (Math.abs(dx) === 4 && Math.abs(dy) === 4);

  if (!aligned) { 
    flash("Impossible : Points non align√©s", "error"); 
    playErrorSound(); 
    return null; 
  }

  const stepX = Math.sign(dx);
  const stepY = Math.sign(dy);

  const segment = [];
  for (let i = 0; i < 5; i++) {
    segment.push(`${start.x + i * stepX},${start.y + i * stepY}`);
  }

  const edges = edgesOfSegment(segment);
  if (edges.some(e => usedEdges.has(e))) {
    flash("Impossible : segment d√©j√† utilis√©", "error");
    playErrorSound();
    return null;
  }

  const activeCount = segment.filter(p => activePoints.has(p)).length;

  if (activeCount < 2) {
    flash("Impossible : au moins 2 points actifs n√©cessaires", "error");
    playErrorSound();
    return null;
  }

  if (activeCount === 5) { 
    gainJoker(); 
    flash("+ 1 joker", "success"); 
    playSuccessSound(); 
  }
  else if (activeCount === 3) {
    if (jokersAvailable >= 1) { 
      loseJoker(1); 
      flash("- 1 joker", "info"); 
    }
    else { 
      flash("Impossible : pas de joker", "error"); 
      playErrorSound(); 
      return null; 
    }
  }
  else if (activeCount === 2) {
    if (jokersAvailable >= 2) { 
      loseJoker(2); 
      flash("- 2 jokers", "info"); 
    }
    else { 
      flash("Impossible : 2 jokers n√©cessaires", "error"); 
      return null; 
    }
  }

  segment.forEach(key => {
    if (!activePoints.has(key)) {
      activePoints.add(key);
      const [px, py] = key.split(",").map(Number);
      drawPoint(px, py);
    }
  });

  edges.forEach(e => usedEdges.add(e));

  return { points: segment, edges, activeCount };
}


// ===============================
//   HISTORIQUE
// ===============================

function appendHistoryEntry(points, activeCount) {
  const historyList = document.getElementById("historyList");
  const li = document.createElement("li");

  const displayed = points.map(p => {
    const [x, y] = p.split(",").map(Number);
    return `${x + 1},${y + 1}`;
  });

  li.textContent = displayed.join(" ‚Üí ");

  if (activeCount === 5) li.className = "gain";
  else if (activeCount === 3 || activeCount === 2) li.className = "loss";
  else li.className = "neutral";

  historyList.appendChild(li);
  historyList.scrollTop = historyList.scrollHeight;
}


// ===============================
//   ANNULATION
// ===============================

function undoLastMove() {
  if (validatedSegments.length === 0) return;

  const last = validatedSegments.pop();

  undoCount++;
  autoSave();
  document.getElementById("undoCount").textContent = undoCount;

  score = Math.max(0, score - 1);

  last.edges.forEach(e => usedEdges.delete(e));

  if (last.activeCount === 5) {
    jokersAvailable = Math.max(0, jokersAvailable - 1);
    jokersTotal     = Math.max(0, jokersTotal - 1);
  } 
  else if (last.activeCount === 3) {
    jokersAvailable += 1;
  } 
  else if (last.activeCount === 2) {
    jokersAvailable += 2;
  }

  last.points.forEach(key => {
    const [kx, ky] = key.split(",").map(Number);

    const stillUsed = validatedSegments.some(s =>
      s.points.some(p => {
        const [px, py] = p.split(",").map(Number);
        return px === kx && py === ky;
      })
    );

    if (!stillUsed && !permanentPoints.has(key)) {
      activePoints.delete(key);
      autoSave();
    }
  });

  const historyList = document.getElementById("historyList");
  if (historyList.lastChild) historyList.removeChild(historyList.lastChild);

  updateCounters();
  redrawEverything();
  updateTutorialButtonState();
}


// ===============================
//   FIN DE PARTIE
// ===============================

function finalizeGameState() {
  gameOver = true;
  autoSave();
  stopTimer();
  localStorage.removeItem("currentGameState");

  const pauseBtn = document.getElementById("pauseBtn");
  const undoBtn  = document.getElementById("undoBtn");

  if (pauseBtn) {
    pauseBtn.disabled = true;
    pauseBtn.classList.add("disabled");
  }

  if (undoBtn) {
    undoBtn.disabled = true;
    undoBtn.classList.add("disabled");
  }
}

function showEndGamePanel() {
  
  const finalScoreEl = document.getElementById("finalScore");
  if (finalScoreEl) {
    finalScoreEl.textContent = "Score final : " + score;
  }

  playEndGameSound();

  gameOver = true;
  autoSave();

  const pauseBtn = document.getElementById("pauseBtn");
  const undoBtn = document.getElementById("undoBtn");

  if (pauseBtn) {
    pauseBtn.disabled = true;
    pauseBtn.classList.add("disabled");
  }

  if (undoBtn) {
    undoBtn.disabled = true;
    undoBtn.classList.add("disabled");
  }

  const overlay = document.getElementById("endGameOverlay");
  if (overlay) overlay.classList.remove("hidden");
}

function isBetterThan(a, b) {
    if (!b) return true; // Aucun record existant

    // 1. Score le plus √©lev√©
    if (a.score !== b.score)
        return a.score > b.score;

    // 2. √Ä score √©gal ‚Üí moins de retours
    if (a.returnsUsed !== b.returnsUsed)
        return a.returnsUsed < b.returnsUsed;

    // 3. √Ä retours √©gal ‚Üí moins de jokers
    return a.jokersUsed < b.jokersUsed;
}


function checkGameOver() {   
  const moves = getPossibleMoves();
  if (moves.length === 0) {

    gameOver = true;
    autoSave();
    stopTimer();
    localStorage.removeItem("currentGameState");

    const current = {
    score,
    returnsUsed: undoCount,
    jokersUsed: jokersTotal - jokersAvailable,
    duration: timerSeconds,
    screenshot: canvas.toDataURL("image/png"),
    date: Date.now()
    };

const best = loadBestScore();
const isNewRecord = isBetterThan(current, best);

if (isNewRecord) {

    // D√©sactivation identique √† la fin de partie
    const pauseBtn = document.getElementById("pauseBtn");
    const undoBtn  = document.getElementById("undoBtn");

    if (pauseBtn) {
      pauseBtn.disabled = true;
      pauseBtn.classList.add("disabled");
    }

    if (undoBtn) {
      undoBtn.disabled = true;
      undoBtn.classList.add("disabled");
    }

    saveBestScore(current);
    updateBestScoreTop();
    playNewRecordSound();
    showBestScorePanel();
    return;
}

    showEndGamePanel();
  }
}


function getPossibleMoves() {
  const moves = [];
  const directions = [
    {dx: 1, dy: 0},
    {dx: 0, dy: 1},
    {dx: 1, dy: 1},
    {dx: 1, dy: -1}
  ];

  for (let key of activePoints) {
    const [x, y] = key.split(",").map(Number);

    for (let dir of directions) {
      const segment = [];

      for (let i = 0; i < 5; i++) {
        const px = x + i * dir.dx;
        const py = y + i * dir.dy;

        if (px < 0 || px >= size || py < 0 || py >= size) {
          segment.length = 0;
          break;
        }

        segment.push(`${px},${py}`);
      }

      if (segment.length !== 5) continue;

      const edges = edgesOfSegment(segment);
      const overlaps = edges.some(e => usedEdges.has(e));
      if (overlaps) continue;

      const activeCount = segment.filter(p => activePoints.has(p)).length;

      if (activeCount < 2) continue;
      if (activeCount === 3 && jokersAvailable < 1) continue;
      if (activeCount === 2 && jokersAvailable < 2) continue;

      moves.push(segment);
    }
  }

  return moves;
}

// ===============================
//   PAUSE
// ===============================

function pauseGame() {
  paused = true;
  clearInterval(timerInterval);
  timerRunning = false;
  document.getElementById("pauseBtn").textContent = "Reprendre";
  flash("Jeu en pause");
}

function resumeGame() {
  paused = false;
  startTimer();
  document.getElementById("pauseBtn").textContent = "Pause";
  flash("Reprise");
}

function togglePause() {
  if (paused) resumeGame();
  else pauseGame();
}


// ===============================
//   R√âINITIALISATION DU JEU
// ===============================

function startNewGame() {
  resetGameState();
  initMaltaCross();
  redrawEverything();
}


function resetGameState() {

  selectedStart = null;
  score = 0;
  paused = false;
  gameOver = false;

  activePoints = new Set();
  permanentPoints = new Set();
  usedEdges = new Set();
  validatedSegments = [];

  jokersAvailable = 0;
  jokersTotal = 0;

  undoCount = 0;
  document.getElementById("undoCount").textContent = "0";

  resetTimer();

  const historyList = document.getElementById("historyList");
  historyList.innerHTML = "";

  ctx.clearRect(0, 0, canvas.width, canvas.height);
}

// ===============================
//   TUTORIEL : CLIGNOTEMENT
// ===============================

function blinkPoint(x, y, duration = 1200) {
  return new Promise(resolve => {
    let visible = true;

    const interval = setInterval(() => {
      redrawEverything();

      if (visible) {
        const cx = offset + x * spacing;
        const cy = offset + y * spacing;

        ctx.beginPath();
        ctx.arc(cx, cy, 12, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(255, 215, 0, 0.35)";
        ctx.fill();

        ctx.beginPath();
        ctx.arc(cx, cy, 4, 0, Math.PI * 2);
        ctx.fillStyle = "#ff0000";
        ctx.fill();
      }

      visible = !visible;
    }, 250);

    setTimeout(() => {
      clearInterval(interval);
      redrawEverything();
      resolve();
    }, duration);
  });
}


// ===============================
//   TUTORIEL : ANIMATION D‚ÄôUNE LIGNE
// ===============================

function animateLine(points) {
  return new Promise(resolve => {
    let i = 0;

    const interval = setInterval(() => {
      if (i >= points.length - 1) {
        clearInterval(interval);
        resolve();
        return;
      }

      const p1 = points[i].split(",").map(Number);
      const p2 = points[i + 1].split(",").map(Number);

      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(offset + p1[0] * spacing, offset + p1[1] * spacing);
      ctx.lineTo(offset + p2[0] * spacing, offset + p2[1] * spacing);
      ctx.stroke();

      i++;
    }, 200);
  });
}


// ===============================
//   TUTORIEL AUTOMATIQUE
// ===============================

function runTutorial() {
  if (tutorialRunning) return;

  tutorialRunning = true;
  currentTutorialStep = 0;

  setButtonsEnabled(false);
  tutorialBtn.disabled = true;
  tutorialBtn.classList.add("disabled");

  playTutorialStep();
}  // ‚Üê FERMER runTutorial ICI


// --------------------------------------
// Fonction ind√©pendante
// --------------------------------------
function drawSegmentProgressively(start, end, onComplete, isTutorial = false) {
  const dx = end.x - start.x;
  const dy = end.y - start.y;
  const stepX = Math.sign(dx);
  const stepY = Math.sign(dy);

  const segment = [];

  const steps = Math.max(Math.abs(dx), Math.abs(dy));
  for (let i = 0; i <= steps; i++) {
    segment.push(`${start.x + i * stepX},${start.y + i * stepY}`);
  }
    animateLine(segment).then(() => {
    segment.forEach(key => {
      const [px, py] = key.split(",").map(Number);
      drawPoint(px, py);
    });

    if (!isTutorial) {
      segment.forEach(key => activePoints.add(key));

      const edges = edgesOfSegment(segment);
      edges.forEach(e => usedEdges.add(e));

      validatedSegments.push({
        points: segment,
        edges: edges,
        activeCount: steps
      });

      score++;
      autoSave();
      updateCounters();
      appendHistoryEntry(segment, steps);
      updateTutorialButtonState();
    }

    if (onComplete) onComplete();
  });
}


function playTutorialStep() {

  // 1) R√©cup√©ration de l‚Äô√©tape
  const step = tutorialSteps[currentTutorialStep];

  // 2) Fin du tutoriel
  if (!step) {
    tutorialRunning = false;
    showTutorialBubble("Tutoriel termin√© !");
    setTimeout(() => hideTutorialBubble(), 2000);
    setButtonsEnabled(true);
    updateTutorialButtonState();
    redrawEverything();
    flash("A vous de jouer", "info");
    return;
  }

  // 3) Mise √† jour visuelle
  if (typeof positionLabels === "function") {
    positionLabels();
  }

  redrawEverything();

  // 4) Affichage du message
  showTutorialBubble(step.message, step.icon);
  const bubble = document.getElementById("tutorialBubble");
  bubble.className = "step" + (currentTutorialStep + 1);

  // 5) Animation : start ‚Üí end ‚Üí segment
  blinkPoint(step.start.x, step.start.y)
    .then(() => blinkPoint(step.end.x, step.end.y))
    .then(() => {
      drawSegmentProgressively(step.start, step.end, () => {

        // 6) Passage √† l‚Äô√©tape suivante
        setTimeout(() => {
          currentTutorialStep++;
          playTutorialStep();
        }, 600);

      }, true);
    });
}

// ===============================
//   INITIALISATION DU JEU (GLOBAL !)
// ===============================

function initGame() {

  const undoBtn = document.getElementById("undoBtn");
  if (undoBtn) {
    undoBtn.disabled = false;
    undoBtn.classList.remove("disabled");
  }

  const restored = false;

  if (!restored || gameOver) {
    resetGameState();
    initMaltaCross();
  }

  redrawEverything();

  updateCounters();
  document.getElementById("undoCount").textContent = undoCount;
  updateSoundButton();

  gameOver = false;
  paused = false;

  updateTutorialButtonState();
  updateBestScoreTop();

  //if (!paused && !gameOver) {
  //  startTimer();
 // }
}

// ===============================
//   DOMContentLoaded
// ===============================

document.addEventListener("DOMContentLoaded", () => {

  // R√©f√©rences DOM essentielles (globales)
  canvas = document.getElementById("gameCanvas");
  ctx = canvas.getContext("2d");
  tutorialBtn = document.getElementById("stepBtn");

  // ===============================
  //   CALCUL R√âEL DU CANVAS + GRILLE
  // ===============================

  // 1) Fixer la taille r√©elle du canvas (CSS ‚Üí JS)
  canvas.width = canvas.clientWidth;
  canvas.height = canvas.clientHeight;

  // 2) Recalculer spacing et offset en fonction de la taille r√©elle
  spacing = canvas.width / (size + 1);
  offset = spacing;

  // ===============================
  //   POSITIONNEMENT DES REP√àRES
  // ===============================

  const topLabels = document.querySelectorAll('#topLabels span');
  const leftLabels = document.querySelectorAll('#leftLabels span');

  if (topLabels.length && leftLabels.length) {

    topLabels.forEach(span => {
      const pos = Number(span.textContent);
      if (!Number.isFinite(pos)) return;
      const x = offset + (pos - 1) * spacing;
      span.style.left = `${x - 6}px`;
    });

    leftLabels.forEach(span => {
      const pos = Number(span.textContent);
      if (!Number.isFinite(pos)) return;
      const y = offset + (pos - 1) * spacing;
      span.style.top = `${y - 6}px`;
    });
  }

  // === Bouton OK fin de partie ===
  document.getElementById("closeEndGame").addEventListener("click", () => {
    document.getElementById("endGameOverlay").classList.add("hidden");
  });

  // === Bouton PAS √Ä PAS ===
  tutorialBtn.addEventListener("click", () => {
    playClickSound();
    if (tutorialRunning) return;

    localStorage.removeItem("currentGameState");

    const modal = document.getElementById("readyModal");
    if (modal) modal.style.display = "none";

    resetGameState();
    initMaltaCross();
    redrawEverything();
    initGame();
    runTutorial();
  });

  // ===============================
  //   LISTENER : CLIC SUR LA GRILLE
  // ===============================

  canvas.addEventListener("click", (e) => {

    if (gameOver) return;
    if (!tutorialRunning && !gameOver && !timerRunning) {
    startTimer();
    }

    if (tutorialRunning) return;

    if (paused) resumeGame();

    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    const nearest = getNearestPoint(mx, my);

    if (!nearest) {
      flash("Hors grille", "error");
      playErrorSound();
      selectedStart = null;
      return;
    }

    const { x, y } = nearest;

    if (!selectedStart) {
      selectedStart = { x, y };
      return;
    }

    const result = getSegmentBetween(selectedStart, { x, y });
    selectedStart = null;

    if (result) {
      playSuccessSound();
      validatedSegments.push(result);
      drawSegment(result.points);
      score++;
      updateCounters();
      appendHistoryEntry(result.points, result.activeCount);
      updateTutorialButtonState();
      checkGameOver();
    }
  });

  // ===============================
  //   BOUTONS
  // ===============================

  document.getElementById("resetBtn").addEventListener("click", () => {
    playClickSound();
    localStorage.removeItem("currentGameState");
    startNewGame();
    initGame();
  });

  document.getElementById("undoBtn").addEventListener("click", () => {
    playClickSound();
    if (!tutorialRunning) undoLastMove();
  });

  document.getElementById("pauseBtn").addEventListener("click", () => {
    playClickSound();
    if (!tutorialRunning) togglePause();
  });

  document.getElementById("helpBtn").addEventListener("click", () => {
  playClickSound();

  const overlay = document.getElementById("helpOverlay");
  if (!overlay) {
    console.error("helpOverlay introuvable dans le DOM");
    return;
  }

  //  Ajustement dynamique pour √©viter que la fen√™tre passe sous le bandeau
  const topBar = document.getElementById("topBar");
  if (topBar) {
    const barHeight = topBar.offsetHeight;
    overlay.style.paddingTop = `${barHeight + 20}px`; // marge de s√©curit√©
  }

  overlay.classList.remove("hidden");
  overlay.style.display = "flex";
});


  document.getElementById("closeHelpBtn").addEventListener("click", () => {
    playClickSound();
    const overlay = document.getElementById("helpOverlay");
    if (!overlay) {
      console.error("helpOverlay introuvable dans le DOM");
      return;
    }
    overlay.style.display = "none";
    overlay.classList.add("hidden");
  });

  document.getElementById("soundBtn").addEventListener("click", () => {
    playClickSound();
    soundEnabled = !soundEnabled;
    updateSoundButton();
  });

  // ===============================
  //   READY BUTTON
  // ===============================

  document.getElementById("readyBtn").addEventListener("click", () => {

    unlockAudio();
    audioUnlocked = true;

    setTimeout(() => playClickSound(), 80);

    document.getElementById("readyModal").style.display = "none";

    initGame();

    const board = document.getElementById("canvasContainer");
    board.classList.remove("show");
    board.classList.add("slide-in-premium");
    void board.offsetWidth;
    board.classList.add("show");

    setTimeout(() => playStartGameSound(), 1800);
  });

  // ===============================
  //   PR√âCHARGEMENT AUDIO
  // ===============================

  window.addEventListener("load", () => {
    const a = document.getElementById("clickSound");
    a.load();
  });

});

</script>
</body>
</html>
